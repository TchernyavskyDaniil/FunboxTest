import React from 'react';
import {Link} from 'react-router-dom';

export default class Level1Component extends React.Component {
  render () {
    return (
      <section className="level-one">
        <h1 className="level-one__header">Level I</h1>
        <Link to="/" className="level-one__back link-button">Назад на главную</Link>

        <article className="level-one__card">
          <div>
            <p>
              Расскажите, чем, на ваш взгляд, отличается хорошее клиентское приложение от
              плохого с точки зрения
            </p>
            <ul>
              <li>пользователя;</li>
              <li>менеджера проекта;</li>
              <li>дизайнера;</li>
              <li>верстальщика;</li>
              <li>серверного программиста.</li>
            </ul>
          </div>
          <div>
            <p>
              1. С точки зрения пользователя приложение должно быть прежде всего удобным. Различные анимации,
              плавные переходы и прочее не имеют смысла, если пользователь не знает, как перейти на нужную страницу
              или не понимает, что с некоторым элементом можно взаимодействовать. Далее влияет скорость работы
              приложения, скорость загрузки и обработки данных. Наиболее важный критерий - скорость отображения
              первого видимого контента.
            </p>
            <p>
              2. С точки зрения менеджера приложение должно позволять качественно распределять обязанности
              по его разработке. Кроме того, приложение должно быть более-менее легко масштабируемым в случае
              дальнейших доработок и усовершенствований.
            </p>
            <p>
              3. Хорошее приложение с точки зрения дизайнера выглядит так, как хочет дизайнер =)
            </p>
            <p>
              4. Для разработки хорошего приложения верстальщику прежде всего надо получить от дизайнера адекватный
              макет. В котором прописаны стайлгайды, используется одно семейство шрифтов, более-менее ровная сетка.
              Далее качество приложения зависит от фронтендера - оптимизация всего, что можно оптимизировать:
              минификация файлов, сжатие картинок, использование svg-спрайтов. По возможности избегать лишних библиотек,
              которые увеличивают общий вес. Использование компонентного подхода для взаимозаменяемости.
            </p>
            <p>
              5. С точки зрения серверного программиста: хорошо налаженный принцип обмена данными между клиентской и
              серверной частями, отказоустойчивость работы бизнес-логики приложения, использование подходящих под задачи
              БД и СУБД.
            </p>
          </div>
        </article>
        <article>
          <div>
            Опишите основные особенности разработки крупных многостраничных сайтов,
            функциональность которых может меняться в процессе реализации и поддержки.
            Расскажите о своем опыте работы над подобными сайтами: какие подходы,
            инструменты и технологии вы применяли на практике, с какими проблемами
            сталкивались и как их решали.
          </div>
          <div>
            <p>
              При разработке крупных сайтов лучше всего использовать модульную структуру. Т.е. необходимо исключить
              воздействие одного модуля (компонента, блока) на внутренности другого модуля (блока). Иначе при
              перестановке или замене составляющих элементов сайта начинается массовая переделка из-за плывущей вёрстки.
              С задачей модульности хорошо справляется БЭМ методология. БЭМ избавляет от проблем хрупкой вложенности
              css-селекторов, опоры на теги при стилизации, задает namespace для более удобной поддержки приложения.
            </p>
            <p>
              Использование препроцессоров также позволяет внедрять переменные в стилизацию (и многое другое), что
              позволяет легко и быстро менять основные цвета при изменении дизайна.
            </p>
            <p>
              В работе над вёрсткой я как раз использую БЭМ и SCSS, что позволяет упростить процесс разработки и
              дальнейшей поддержки проекта.
            </p>
          </div>
        </article>
        <article>
          <div>
            При разработке интерфейсов с использованием компонентной архитектуры часто
            используются термины Presentational Сomponents и Сontainer Сomponents. Что
            означают данные термины? Зачем нужно такое разделение, какие у него есть
            плюсы и минусы?
          </div>
          <div>
            <p>
              Если говорить о React, то Presentational Сomponents отвечают исключительно за view-составляющую компонента
              и той части приложения, которую они представляют. Т.е. Presentational Сomponents не контактируют с
              глобальным хранилищем состояний
            </p>
            <p>
              Сontainer Сomponents в свою очередь контактируют с хранилищем состояний через React-Redux и передают
              нужные части состояния своим потомкам-компонентам. Это позволяет снизить число общих точек между
              представлением и моделью (состоянием) приложения.
            </p>
            <p>
              Плюсом является то, что лишь небольшая часть компонентов непосредственно влияет на состояние. Также легче
              проследить поток изменения состояния в жизненном цикле react-приложения
            </p>
          </div>
        </article>
        <article>
          <div>
            Как устроено наследование в JS? Расскажите о своем опыте реализации JS наследования
            без использования фреймворков.
          </div>
          <div>
            <p>
              Наследование в JS построено через прототипы. У каждого объекта есть свой прототип - тоже объект, в который
              могут быть записаны свойства и методы. Суть прототипов в том, что когда мы создаем некий новый объект,
              те методы и свойства, которые записаны в его прототип, сразу будут доступны, даже если новый объект -
              пустой.
            </p>
            <p>
              Соответственно, если какой-то подкласс должен унаследовать свойства и методы абстрактного родительского
              класса, это можно сделать через копирование прототипа родительского класса.
            </p>
            <pre>
              Пример:
              {`
              const Vehicle = function () {...}
              Vehicle.prototype.move = () => {console.log('I can move')};

              const Car = function () {...}
              Car.prototype = Object.create(Vehicle.prototype); // для объектов Car будет доступен метод move
            `}
            </pre>
          </div>
        </article>
        <article>
          <div>
            Какие библиотеки можно использовать для написания тестов end-to-end во
            фронтенде? Расскажите о своем опыте тестирования веб-приложений.
          </div>
          <div>
            <p>
              Для тестирования чаще всего используются библиотеки Mocha и Chai. На данный момент у меня нет опыта
              написания автотестов.
            </p>
          </div>
        </article>
        <article>
          <div>
            Вам нужно реализовать форму для отправки данных на сервер, состоящую из
            нескольких шагов. В вашем распоряжении дизайн формы и статичная верстка, в
            которой не показано, как форма должна работать в динамике. Подробного
            описания, как должны вести себя различные поля в зависимости от действий
            пользователя, в требованиях к проекту нет. Ваши действия?
          </div>
          <div>
            <p>
              Прежде всего, надо узнать, на какой адрес делать POST запрос при отправке формы. Далее надо подумать,
              какие поля могут быть обязательными для заполнения и в каких нужно вводить данные определенного типа.
              На основании этого добавить валидацию формы. Также желательно добавить сообщения для пользователя об
              успешной или не успешной отправке. Поскольку в ТЗ подобных требований нет, постараюсь сделать по своему
              усмотрению и далее согласовывать с заказчиком.
            </p>
          </div>
        </article>
        <article>
          <div>
            Расскажите, какие инструменты помогают вам экономить время в процессе
            написания, проверки и отладки кода.
          </div>
          <div>
            <p>
              Прежде всего, это сама IDE - я пользуюсь WebStorm. Далее в дело вступают линтеры (ESLint, Stylelint,
              editorconfig) и средства автоматизации сборки (в основном, я использую Gulp). Для отладки, например,
              использую devtools в браузере. Для ускорения написания разметки использую Emmet
            </p>
          </div>
        </article>
        <article>
          <div>
            Какие ресурсы вы используете для развития в профессиональной сфере? Приведите
            несколько конкретных примеров (сайты, блоги и так далее).
            Какие ещё области знаний, кроме тех, что непосредственно относятся к работе,
            вам интересны?
          </div>
          <div>
            <p>
              Подписан на различные каналы и группы, которые освещают новости фронтенд-мира (например,
              группа "Веб-стандарты", канал "For Web" в Telegram. Читаю статьи на Хабре, Medium
            </p>
            <p>
              В качестве справочника постоянно пользуюсь Mozilla Developers Network (MDN). Некоторое время назад
              часто решал задачки на Codewars.
            </p>
          </div>
        </article>
        <article>
          <div>
            Расскажите нам немного о себе и предоставьте несколько ссылок на последние
            работы, выполненные вами.
          </div>
          <div>
            <p>
              Подробнее обо мне можно узнать в <a href="https://ge11ert.github.io/">онлайн-версии резюме</a>
            </p>
            <p>
              Ссылки на выполненные работы находятся там же, в разделе
              <a href="https://ge11ert.github.io/#works">Мои работы</a>
            </p>
          </div>
        </article>

      </section>
    );
  }
};
